"""
SQL MCP Implementation
----------------------

This module implements a Model Context Protocol for relational database
operations using SQLite.  It accepts natural language commands and
translates them into SQL via `english_to_sql`.  The MCP executes
queries, performs optional assertions and attaches evidence on
failures.  A persistent SQLite connection is maintained across steps.
"""

import sqlite3
from pathlib import Path
from typing import Any, Dict

from .mcp_base import MCPBase
from ..utils.natural_language_sql import english_to_sql
try:
    from ..utils.llm_client import LLMClient  # type: ignore
except Exception:
    LLMClient = None  # type: ignore


class SQLMCP(MCPBase):
    """MCP implementation for SQL operations using SQLite.

    Natural language commands are translated into SQL using either an LLM
    client (if configured) or the ruleâ€‘based `english_to_sql` helper.
    The optional assertion generated by the LLM is attached to the
    report for manual verification.
    """

    def __init__(self, config, reporter, llm_client: Any | None = None) -> None:
        super().__init__(config, reporter)
        db_url = config.get("database.url", "sqlite:///./test.db")
        if db_url.startswith("sqlite:///"):
            db_path = db_url[len("sqlite:///"):]
        else:
            db_path = db_url
        Path(db_path).parent.mkdir(parents=True, exist_ok=True)
        self.conn = sqlite3.connect(db_path)
        self.cursor = self.conn.cursor()
        self.cursor.execute(
            "CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT)"
        )
        self.conn.commit()
        # LLM client
        if llm_client is not None:
            self.llm = llm_client
        elif LLMClient is not None:
            try:
                self.llm = LLMClient(config)
            except Exception:
                self.llm = None
        else:
            self.llm = None

    def _execute_step(self, step: Dict[str, Any]) -> None:
        command = step.get("command")
        if not command:
            raise ValueError("SQL step missing 'command'")
        # LLM translation if available
        sql_stmt: Optional[str] = None
        assertion_desc: Optional[str] = None
        if self.llm and hasattr(self.llm, "translate_sql"):
            try:
                result = self.llm.translate_sql(command)
                sql_stmt = result.sql
                assertion_desc = result.assertion
            except Exception:
                sql_stmt = None
        if not sql_stmt:
            translation = english_to_sql(command)
            sql_stmt = translation.sql
            # If rule based translation included an assertion function we can attach its docstring
            if translation.assertion is not None:
                assertion_desc = translation.assertion.__doc__  # type: ignore
        # Execute the SQL
        self.cursor.execute(sql_stmt)
        if sql_stmt.lstrip().lower().startswith("insert") or sql_stmt.lstrip().lower().startswith("delete") or sql_stmt.lstrip().lower().startswith("update"):
            self.conn.commit()
        self.reporter.attach_text(sql_stmt, name="sql_statement")
        # Attach assertion description if present
        if assertion_desc:
            self.reporter.attach_text(assertion_desc, name="sql_assertion")

    def close(self) -> None:
        try:
            self.conn.commit()
            self.conn.close()
        except Exception:
            pass

    def __del__(self):
        self.close()